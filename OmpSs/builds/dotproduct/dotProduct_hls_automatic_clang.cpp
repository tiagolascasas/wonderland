///////////////////
// Automatic IP Generated by OmpSs@FPGA compiler
///////////////////
// The below code is composed by:
//  1) User source code, which may be under any license (see in original source code)
//  2) OmpSs@FPGA toolchain code which is licensed under LGPLv3 terms and conditions
///////////////////
// Top IP Function: dotProduct
// Accel. type hash: 5473272960
// Num. instances: 1
// Wrapper version: 13
///////////////////

#include <hls_stream.h>
#include <ap_int.h>
#include <ap_axi_sdata.h>
static ap_uint<64> __mcxx_taskId;

template <class T>
union __mcxx_cast
{
    unsigned long long int raw;
    T typed;
    __mcxx_cast() {}
};

struct mcxx_inaxis
{
    ap_uint<64> data;
};
typedef ap_axiu<64, 1, 1, 2> mcxx_outaxis;
const unsigned int BSIZE = 32;
void dotProduct(float *v1, float *v2, float *result)
{
    int resultLocal = result[0];
    for (unsigned int i = 0; i < BSIZE; ++i)
    {
        resultLocal += v1[i] * v2[i];
    }
    result[0] = resultLocal;
}
void mcxx_write_out_port(const ap_uint<64> data, const ap_uint<2> dest, const ap_uint<1> last, hls::stream<mcxx_outaxis> &mcxx_outPort)
{
#pragma HLS inline
    mcxx_outaxis axis_word;
    axis_word.data = data;
    axis_word.dest = dest;
    axis_word.last = last;
    mcxx_outPort.write(axis_word);
}
void dotProduct_wrapper(hls::stream<ap_uint<64>> &mcxx_inPort, hls::stream<mcxx_outaxis> &mcxx_outPort, float *mcxx_v1, float *mcxx_v2, float *mcxx_result)
{
#pragma HLS interface ap_ctrl_none port = return
#pragma HLS interface axis port = mcxx_inPort
#pragma HLS interface axis port = mcxx_outPort
#pragma HLS interface m_axi port = mcxx_v1
#pragma HLS interface m_axi port = mcxx_v2
#pragma HLS interface m_axi port = mcxx_result
    mcxx_inPort.read(); // command word
    __mcxx_taskId = mcxx_inPort.read();
    ap_uint<64> __mcxx_parent_taskId = mcxx_inPort.read();
    float *v1;
    float *v2;
    float *result;
    {
#pragma HLS protocol fixed
        {
            ap_uint<8> mcxx_flags_0;
            ap_uint<64> mcxx_offset_0;
            mcxx_flags_0 = mcxx_inPort.read()(7, 0);
            ap_wait();
            mcxx_offset_0 = mcxx_inPort.read();
            v1 = mcxx_v1 + mcxx_offset_0 / sizeof(float);
        }
        ap_wait();
        {
            ap_uint<8> mcxx_flags_1;
            ap_uint<64> mcxx_offset_1;
            mcxx_flags_1 = mcxx_inPort.read()(7, 0);
            ap_wait();
            mcxx_offset_1 = mcxx_inPort.read();
            v2 = mcxx_v2 + mcxx_offset_1 / sizeof(float);
        }
        ap_wait();
        {
            ap_uint<8> mcxx_flags_2;
            ap_uint<64> mcxx_offset_2;
            mcxx_flags_2 = mcxx_inPort.read()(7, 0);
            ap_wait();
            mcxx_offset_2 = mcxx_inPort.read();
            result = mcxx_result + mcxx_offset_2 / sizeof(float);
        }
        ap_wait();
    }
    dotProduct(v1, v2, result);
    {
#pragma HLS protocol fixed
        ap_uint<64> header = 0x03;
        ap_wait();
        mcxx_write_out_port(header, 0, 0, mcxx_outPort);
        ap_wait();
        mcxx_write_out_port(__mcxx_taskId, 0, 0, mcxx_outPort);
        ap_wait();
        mcxx_write_out_port(__mcxx_parent_taskId, 0, 1, mcxx_outPort);
        ap_wait();
    }
}
